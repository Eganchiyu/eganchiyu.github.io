---
title: 本地计算机、树莓派配置ssh
excerpt: 通过ssh优化远程访问

categories: 
  -  树莓派

tags:
  -  博客
  -  记录
  -  树莓派
  -  嵌入式
comments: true
entries_layout: grid

# header:
#     teaser: 

---

# 前言

相信其实大家对HTTPS协议网络了解比较深入，并且多多少少也感受到了它的一些不方便之处

我另外写了一篇SSH的工作原理，可以作为预备知识，不过对这篇文章的工作流没有影响，可以放心食用

接下来会围绕基本如何部署、为什么要从HTTPS切换到SSH这两个方面来展开

# SSH的通信原理

SSH的核心在于如何在完全不加密的网络通道上，建立起绝对安全的加密会话

主要分为两个阶段

## 第一阶段：密钥交换(Key Exchange / Handshake)

#### 1. 版本协商（明文传输）

双方互相发送支持的SSH版本（如SSH-2.0）

具体数据字节可以参考[这篇博客](https://www.cnblogs.com/dier-gaohe/p/16971894.html)，解释的非常清楚

具体流程如下，参考了[这篇博客](https://blog.csdn.net/m0_56763594/article/details/127390391)：

1. **服务器端监听**
   - 服务器开放 TCP 端口 22，等待客户端连接

2. **客户端发起连接**
   - 客户端向服务器端发起 TCP 初始连接请求

3. **服务器发送版本标识**
   - 服务器向客户端发送第一个报文，包含版本标志字符串，格式为：  
     ```
     SSH-<主协议版本号>.<次协议版本号>.<软件版本号>
     ```
   - 其中：
     - 协议版本号 = 主版本号 + 次版本号
     - 软件版本号主要用于调试和实现标识

4. **客户端解析并选择协议版本**
   - 客户端解析服务器发送的版本信息：
     - 若服务器协议版本低于客户端版本，且客户端支持该低版本，则采用服务器端协议版本；
     - 否则，使用客户端自身的协议版本。

5. **客户端回应版本号**
   - 客户端向服务器发送报文，告知最终选定的协议版本号。

6. **服务器确认协商结果**
    - 若协商成功，进入**密钥交换与算法协商阶段**；
    - 若协商失败，服务器直接断开 TCP 连接。


#### 算法协商

双方交换支持的加密算法列表（如 Ed25519, AES-GCM 等），并选择最优解

3. 生成共享密钥


# 为什么要从HTTPS切换到SSH?

拿Github来讲，我之前的Git操作都是通过HTTPS协议完成的

比如，我的远程仓库就是https://github.com/Eganchiyu

那么我就直接push到这个网址就行了，握手后，服务器会做一系列操作，本次请求就算完成

但是在中国用过github的都知道，github的网络是何等的不稳定，一旦dns污染了，就根本完成不了这些基本的操作了

## HTTPS和SSH协议比对

| 特性 | HTTPS (HyperText Transfer Protocol Secure) | SSH (Secure Shell) |
|------|-------------------------------------------|--------------------|
| 底层协议 | 建立在 TLS/SSL 之上，运行在 443 端口。 | 独立的 SSH 协议，通常运行在 22 端口。 |
| 身份验证 | 主要是基于证书颁发机构（CA）。客户端验证服务器的证书是否由受信任的机构签发。 | 基于非对称加密。客户端将公钥给服务器，服务器通过挑战/响应机制验证客户端持有的私钥。 |
| 连接过程 | 涉及复杂的 TLS 多次握手（Client Hello、Server Hello、交换证书等）。 | 相对简洁的密钥交换和身份验证流程。 |
| 主要用途 | 网页浏览、通用 API 调用。 | 远程管理服务器、代码托管同步（Git）。 |

## 为什么SSH更稳定？

我们常遇到的 GnuTLS recv error (-110) 本质上是连接重置（Connection Reset）或握手超时

SSH 能够解决这个问题，主要有以下几个原因：

#### 1. 规避深度包检测 (DPI) 的干扰

HTTPS (443端口) 流量巨大且复杂。国内网络环境会对 TLS 握手包进行高强度的扫描和检测（为了识别 SNI 信息）

如果检测过程中出现丢包或延迟，握手就会失败

SSH (22端口) 的流量特征与网页浏览完全不同，其流量相对“纯粹”，受到的针对性协议干扰有时比 HTTPS 略小。

#### 2. 状态保持与重连机制

HTTPS 是无状态的短连接，每次 git push/pull 都要重新经历完整的 TLS 握手流程，任何一次握手失败都会报错

SSH 在建立连接时，验证的是你预先存放在 GitHub 上的公钥。只要 RSA/Ed25519 的密钥交换完成，连接就会非常稳固

对于 Git 操作，SSH 的处理逻辑更直接，减少了因证书校验失败导致的意外中断。

#### 3. 绕过过载的 Web 代理/网关

很多运营商或校园网会对 443 端口（网页流量）进行复杂的流量整形（Traffic Shaping）或代理缓存

由于 SSH 流量通常被视为“运维/管理”流量，往往能避开这些针对普通网页访问的限速或过滤规则<span title = '你知道的太多了' class = 'heimu'>（装大佬这一块）</span>

## 局限性：HTTPS和SSH都无法解决DNS污染

在正常的网络环境下，DNS 服务器会返回 GitHub 真实的 IP（比如 20.205.243.166）。但在受污染的环境下，中间节点返回一个错误的、无法访问的、甚至是虚假的 IP 地址。

这在HTTPS和SSH中都会有表现：

1. HTTPS 表现：获取Ip错误，浏览器尝试去跟这个错误 IP 建立 TLS 连接。由于 IP 根本不对，握手会直接超时，或者报错“证书不匹配”

2. SSH 表现：解析出的 github.com 错误，ssh -T git@github.com 会连接失败